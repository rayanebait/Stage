

# This file was *autogenerated* from the file find_sum_2_squares.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_1 = Integer(1)
from time import time
from argparse import ArgumentParser

from utilities.find_prime import find_prime_with_torsion

parser = ArgumentParser()
parser.add_argument("-t", "--two_torsion", default = "128")
parser.add_argument("-T", "--three_torsion", default = "1")

args = parser.parse_args()

"""
data:
    -N is the rational torsion available
    -d is the isogeny degree
    -D is the torsion we take
"""
tt=Integer(args.two_torsion)
Tt=Integer(args.three_torsion)

D = _sage_const_2 **(tt)
d = _sage_const_3 **(Tt)
N = d*D


p, cofactor = find_prime_with_torsion(N)

print(f"Found prime {p}=2**{tt}*3**{Tt}*({factor(cofactor)})-1\n\n")

"""2**a ~ p, 3**b = p**(1/3)"""
b = floor(log(_sage_const_2 ,_sage_const_3 )*tt/_sage_const_3 )

""""""
r = Integer(log(p))
dA = _sage_const_3 **b-r
while dA < _sage_const_3 **b+r:
    fac = factor(_sage_const_2 **a-(_sage_const_3 **b)*dA)
    if [p[_sage_const_0 ]%_sage_const_4  for p in fac] == [_sage_const_1 ]*len(fac):
        break
    dA+=_sage_const_1 

assert dA != _sage_const_3 **b+r

print(dA)

