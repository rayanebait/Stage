

# This file was *autogenerated* from the file find_sum_2_squares.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3); _sage_const_0p5 = RealNumber('0.5')
from time import time
from argparse import ArgumentParser
from pprint import pprint

from utilities.find_prime import find_prime_with_torsion
from utilities.quaternion import cornacchia_smith
from utilities.ecm_with_abort import ecm_with_abort

proof.arithmetic(False)

def two_squares_ecm(n, factors):
    if n < _sage_const_0 :
        return None
    if n == _sage_const_0 :
        return _sage_const_0 , _sage_const_0 
    if n == _sage_const_1 :
        return _sage_const_1 , _sage_const_0 
    a, b = _sage_const_1 , _sage_const_0 
    q_=_sage_const_1 
    for q in factors:
        if q!=q_:
            e = _sage_const_0 
            q_ = q
        while n % q == _sage_const_0 :
            n //= q
            e += _sage_const_1 
        a *= q**(e//_sage_const_2 )
        b *= q**(e//_sage_const_2 )
        if e % _sage_const_2  == _sage_const_1 :
            if q % _sage_const_4  == _sage_const_3 :
                return None
            else:
                s, t = cornacchia_smith(q)
                at = a*s - b*t
                bt = a*t + b*s
                a, b = at, bt
    print(n)
    return a, b


parser = ArgumentParser()
parser.add_argument("-t", "--two_torsion", default = "128")
parser.add_argument("-T", "--three_torsion", default = "1")
parser.add_argument("-p", "--as_prime", action = "store_true")

args = parser.parse_args()

"""
data:
    -N is the rational torsion available
    -d is the isogeny degree
    -D is the torsion we take
    -as_prime, chooses wether we search fo 2**a-3**bd_A as a prime
        or factorize it with ecm_with_abort
"""
a=Integer(args.two_torsion)
b=Integer(args.three_torsion)

D = _sage_const_2 **(a)
d = _sage_const_3 **(b)
N = d*D
as_prime = args.as_prime


p, cofactor = find_prime_with_torsion(N)

print(f"Found prime {p}=2**{a}*3**{b}*({factor(cofactor)})-1\n\n")

"""2**a ~ p, 3**b = p**(1/3)"""
b = floor(log(_sage_const_2 ,_sage_const_3 )*a/_sage_const_3 )

""""""
r = ceil(log(p, _sage_const_2 ))
dA = _sage_const_3 **b-r
n = _sage_const_2 **a - (_sage_const_3 **(_sage_const_2 *b))*dA
res = _sage_const_1 , _sage_const_1 

if as_prime:
    r = ceil(log(p))
    while dA < _sage_const_3 **b+r:
        print('.', end ='')
        if n.is_pseudoprime():
            print("Found pseudo prime {n}\n")
            if n in Primes() and n%_sage_const_4  == _sage_const_1 :
                print("Found candidate {n}\n")
                break
        n-=_sage_const_3 **b
        dA+=_sage_const_1 

    assert dA != _sage_const_3 **b+r
    x, y = cornacchia_smith(n)
else:
    fac = []
    while dA < _sage_const_3 **b+r:
        fac = ecm_with_abort(n, _sage_const_0p5 )
        print(fac)
        if fac != None:
            res = two_squares_ecm(n, fac)
            if res != None:
                break
        n-=_sage_const_3 **b
        dA+=_sage_const_1 

    assert dA != _sage_const_3 **b+r

    x, y = res

print(f"Found:\n\t x={x},\n\ty={y}")
print(f"With sum:\n\t x**2+y**2={x**_sage_const_2 +y**_sage_const_2 }")
print(f"For n={n}")
assert x**_sage_const_2 +y**_sage_const_2  == n

print(f"And remainder/quotient r={r}, dA={dA}")





