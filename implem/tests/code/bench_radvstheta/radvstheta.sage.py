

# This file was *autogenerated* from the file radvstheta.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3)
from time import time
from argparse import ArgumentParser

from theta_structures.couple_point import CouplePoint
from theta_isogenies.product_isogeny_sqrt    import EllipticProductIsogenySqrt


from utilities.supersingular import compute_point_order_D, torsion_basis
from utilities.find_prime import find_prime_with_torsion
from utilities.parameter_generate import calcFields

import elliptic_curve as ec
import utilities.utilities_festa as utils
import utilities.endomorphism as End
import utilities.quaternion as quat 



parser = ArgumentParser()
parser.add_argument("-t", "--two_torsion", default = "128")
parser.add_argument("-T", "--three_torsion", default = "100")

args = parser.parse_args()

def Fp2ToFp2d(x, zeta2, Fp2d):
    return ZZ((x + x**p)/_sage_const_2 ) + ZZ((x - x**p)/(_sage_const_2 *zeta2)) * Fp2d.gen()

def Fp2dToFp2(x, zeta2, Fp2d):
    i = Fp2d.gen()
    x_= ZZ((x + x**p)/_sage_const_2 ) + ZZ((x - x**p)/(_sage_const_2  * i)) * zeta2 
    return x_

def basis_change_ring(E0, basis, zeta2, Fp2d):
    basis =[E0(Fp2dToFp2(P[_sage_const_0 ], zeta2, Fp2d),               Fp2dToFp2(P[_sage_const_1 ], zeta2, Fp2d))                for P in basis]
    return basis

"""
TODO: use e2-2 instead of e2 for theta isogenies and EllipticProduct
Isogeny instead of EllipticProductIsogenySqrt
"""
def NonSmoothRandomIsog(e, N, basis2, action_matrices, strategy, use_theta=False):
    P, Q = basis2
    E0 = P.curve()
    p = E0.base_ring().characteristic()
    assert N % _sage_const_2  == _sage_const_1 
    assert (p + _sage_const_1 ) % _sage_const_2 **e == _sage_const_0 
    assert ((_sage_const_2 **e)*P).is_zero() and ((_sage_const_2 **e)*Q).is_zero()
    assert ((_sage_const_2 **(e-_sage_const_1 ))*P).weil_pairing((_sage_const_2 **(e-_sage_const_1 ))*Q, _sage_const_2 ) == -_sage_const_1 

    alpha = quat.FullRepresentInteger(N*(_sage_const_2 **e - N), p)
    vP = End.action_by_matrices(alpha, [_sage_const_1 , _sage_const_0 ], action_matrices)
    alphaP = vP[_sage_const_0 ]*P + vP[_sage_const_1 ]*Q
    vQ = End.action_by_matrices(alpha, [_sage_const_0 , _sage_const_1 ], action_matrices)
    alphaQ = vQ[_sage_const_0 ]*P + vQ[_sage_const_1 ]*Q
 
    assert P.weil_pairing(Q, _sage_const_2 **e)**(N*(_sage_const_2 **e - N)) == alphaP.weil_pairing(alphaQ, _sage_const_2 **e)
    if use_theta:
        X, Y, XY = d2isogeny.D2IsogenyImage(E0, E0, (_sage_const_2 **e - N)*P, (_sage_const_2 **e - N)*Q, alphaP, alphaQ, e, [(P, E0(_sage_const_0 )), (Q, E0(_sage_const_0 )), (P + Q, E0(_sage_const_0 ))], strategy, use_theta)
        if not (X[_sage_const_0 ] + Y[_sage_const_0 ] == XY[_sage_const_0 ] or X[_sage_const_0 ] + Y[_sage_const_0 ] == -XY[_sage_const_0 ]):
            Y[_sage_const_0 ] = -Y[_sage_const_0 ]
        Pd, Qd = X[_sage_const_0 ], Y[_sage_const_0 ]
        if not Pd.weil_pairing(Qd, _sage_const_2 **e) == P.weil_pairing(Q, _sage_const_2 **e)**N:
            if not (X[_sage_const_1 ] + Y[_sage_const_1 ] == XY[_sage_const_1 ] or X[_sage_const_1 ] + Y[_sage_const_1 ] == -XY[_sage_const_1 ]):
                Y[_sage_const_1 ] = -Y[_sage_const_1 ]
            Pd, Qd = X[_sage_const_1 ], Y[_sage_const_1 ]
        assert Pd.weil_pairing(Qd, _sage_const_2 **e) == P.weil_pairing(Q, _sage_const_2 **e)**N
    else:
        X, Y = d2isogeny.D2IsogenyImage(E0, E0, (_sage_const_2 **e - N)*P, (_sage_const_2 **e - N)*Q, alphaP, alphaQ, e, [(P, E0(_sage_const_0 )), (Q, E0(_sage_const_0 ))], strategy, use_theta)
        Pd, Qd = X[_sage_const_0 ], Y[_sage_const_0 ]
        if not Pd.weil_pairing(Qd, _sage_const_2 **e) == P.weil_pairing(Q, _sage_const_2 **e)**N:
            Pd, Qd = X[_sage_const_1 ], Y[_sage_const_1 ]
        assert Pd.weil_pairing(Qd, _sage_const_2 **e) == P.weil_pairing(Q, _sage_const_2 **e)**N

    return Pd, Qd

"""
TODO: use e2-2 instead of e2 for theta isogenies and EllipticProduct
Isogeny instead of EllipticProductIsogenySqrt
"""
def get_matrices(E0, l, e, Fp2d, basis=None):
    p = E0.base_ring().characteristic()

    assert ((p+_sage_const_1 )%(l**e) == _sage_const_0 )
    assert E0 == EllipticCurve(Fp2d, [_sage_const_1 ,_sage_const_0 ])

    if basis == None:
        basis = torsion_basis(E0, l**e)

    """
    Changing the field of definition to a subfield of Fp4 only for 
    action_matrices.
    """
    Fp4, Fp2, zeta2 = calcFields(p)
    E0=EllipticCurve(Fp2, [_sage_const_1 ,_sage_const_0 ])

    basis_bis = basis_change_ring(E0, basis, zeta2, Fp2d)

    Ms = End.action_matrices(basis_bis ,l**e ,zeta2, Fp4)

    return Ms

"""
Pushes an isogeny:
    E0--->EA
of degree q(2**e2-q) to a random 
    Es--->~Es
of the same degree through parallel 3**e3 isogenies.
I'm giving P0, Q0 because I'm not using the canonical 
2**e2-basis.
"""
"""
phi: E->E1 is a q-isogeny, psi:E1 -> E_ a 2^e-q-isogeny forming:
                  phi
                E----->E1
                |      |
                |      |
            psi'|      | psi
                |      |
                E2---->E_
                  phi'
with f = psi*phi 
    -We compute the isogeny with kernel <-q*P, psi*phi(P), P in E[2^e]>
        from ExE_ to E1xE2 of matrix (phi -hatpsi )
                                     (phi' hatpsi')
"""
def Kani_from_kernel(E, E_, P, Q, fP, fQ, q, e):
    kernel = [CouplePoint(q*P, fP), CouplePoint(q*Q, fQ)]
    Phi = EllipticProductIsogenySqrt(kernel, e)
    return Phi

"""Evaluates a non smooth isogeny of degree q in higher dimensional 
representation by Phi, on the l^e torsion"""
def eval_q_2a_q_from_kani(Phi, Pl, Ql, Pl_, Ql_, l, e, as_vector = True):
    O=Pl-Pl
    O_=Pl_-Pl_
    Rs = [[Pl, O_], [Ql, O_], [O, Pl_], [O, Ql_]]
    Rs = [CouplePoint(R[_sage_const_0 ], R[_sage_const_1 ]) for R in Rs]
    Rs = [Phi(R) for R in Rs]

    xP, yP = utils.BiDLP(Rs[_sage_const_0 ][_sage_const_0 ], Rs[_sage_const_2 ][_sage_const_0 ], Rs[_sage_const_3 ][_sage_const_0 ], l**e)
    xQ, yQ = utils.BiDLP(Rs[_sage_const_1 ][_sage_const_0 ], Rs[_sage_const_2 ][_sage_const_0 ], Rs[_sage_const_3 ][_sage_const_0 ], l**e)

    if as_vector:
        return [xP, yP], [xQ, yQ]
    else:
        return xP*Pl_+yP*Ql_, xQ*Pl_+yQ*Ql_

def eval_non_smooth_from_kani(Phi, Pl, Ql, Pl_, Ql_, q, e, l=_sage_const_2 ):
    O=Pl-Pl
    O_=Pl_-Pl_
    Rs = [[Pl, O_], [Ql, O_], [Pl+Ql, O_]]
    Rs = [CouplePoint(R[_sage_const_0 ], R[_sage_const_1 ]) for R in Rs]
    X, Y, XY = [Phi(R) for R in Rs]

    if not (X[_sage_const_0 ] + Y[_sage_const_0 ] == XY[_sage_const_0 ] or X[_sage_const_0 ] + Y[_sage_const_0 ] == -XY[_sage_const_0 ]):
        Y[_sage_const_0 ] = -Y[_sage_const_0 ]
    Pd, Qd = X[_sage_const_0 ], Y[_sage_const_0 ]
    if not Pd.weil_pairing(Qd, l**e) == Pl.weil_pairing(Ql, l**e)**q:
        if not (X[_sage_const_1 ] + Y[_sage_const_1 ] == XY[_sage_const_1 ] or X[_sage_const_1 ] + Y[_sage_const_1 ] == -XY[_sage_const_1 ]):
            Y[_sage_const_1 ] = -Y[_sage_const_1 ]
        Pd, Qd = X[_sage_const_1 ], Y[_sage_const_1 ]
    assert Pd.weil_pairing(Qd, l**e) == Pl.weil_pairing(Ql, l**e)**q

    return Pd, Qd

"""
data:
    -N is the rational torsion available
    -d is the isogeny degree
    -D is the torsion we take
"""
e2=Integer(args.two_torsion)
D = _sage_const_2 **(_sage_const_3 *e2)
d = _sage_const_3 
N = d*D

e3 = ceil(log(_sage_const_2 ,_sage_const_3 )*e2)

p, cofactor = find_prime_with_torsion(N)
while cofactor%_sage_const_3  == _sage_const_0 :
    p, cofactor = find_prime_with_torsion(N, cofactor+_sage_const_1 )

print(f"Found prime {p}=2**(3*{e2})*3*({factor(cofactor)})-1\n\n")

Fp2d = GF(p**_sage_const_2 , modulus=[_sage_const_1 ,_sage_const_0 ,_sage_const_1 ], name="i")
E0=EllipticCurve(Fp2d, [_sage_const_1 ,_sage_const_0 ])

q = randint(_sage_const_0 , _sage_const_2 **(_sage_const_2 *e2))
while q*(_sage_const_2 **(_sage_const_3 *e2)-q)%_sage_const_2  == _sage_const_0  or q*(_sage_const_2 **(_sage_const_3 *e2)-q)%_sage_const_3  == _sage_const_0 :
    q = randint(_sage_const_0 , _sage_const_2 **(_sage_const_2 *e2))

P0, Q0 = torsion_basis(E0, _sage_const_2 **(_sage_const_3 *e2))
Ms = get_matrices(E0, _sage_const_2 , _sage_const_3 *e2, Fp2d, basis=[P0, Q0])

theta = quat.FullRepresentInteger(q*(_sage_const_2 **(_sage_const_3 *e2) - q), p)

print(f"Found endomorphism with coefficients: {theta}")
vthetaP0 = End.action_by_matrices(theta, [_sage_const_1 ,_sage_const_0 ], Ms)
vthetaQ0 = End.action_by_matrices(theta, [_sage_const_0 ,_sage_const_1 ], Ms)

thetaP0 = vthetaP0[_sage_const_0 ]*P0+vthetaP0[_sage_const_1 ]*Q0
thetaQ0 = vthetaQ0[_sage_const_0 ]*P0+vthetaQ0[_sage_const_1 ]*Q0

t0 = time()
Phi = Kani_from_kernel(E0, E0, P0, Q0, thetaP0, thetaQ0, q, _sage_const_3 *e2)
t1 = time()
P1, Q1 = eval_non_smooth_from_kani(Phi, P0, Q0, thetaP0,                                    thetaQ0, q, _sage_const_3 *e2)

E1 = P1.curve()

print(f"Computed isogeny\n\n\
        {E0.j_invariant()}--->{E1.j_invariant()}\n\n\
        In time {t1-t0}\n")

print(f"Now computing radical isogenies:\n\n")
sleep(_sage_const_1 )
t3 = time()
PQ1 = P1+Q1

zeta3 = (-_sage_const_1  + Fp2d(-_sage_const_3 ).sqrt())/_sage_const_2 

E1_, xs = ec.chain_3radials(E1, [P1.xy()[_sage_const_0 ], Q1.xy()[_sage_const_0 ], PQ1.xy()[_sage_const_0 ]],zeta3, _sage_const_2 *e3)
t4 = time()

print(f"Computed new isogeny {E1.j_invariant()}--->{E1_.j_invariant()}\n\
        ")
print(f"In time: {t4-t3}")






